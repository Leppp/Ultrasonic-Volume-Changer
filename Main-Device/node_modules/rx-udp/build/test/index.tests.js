"use strict";
var chai_1 = require("chai");
var Rx = require("rx");
var dgram = require("dgram");
var rxUdp = require("../src");
var SERVER_PORT = 9999;
var SERVER_HOST = "localhost";
describe("rx udp", function () {
    describe("observable udp socket tests", function () {
        it("should apply map function to messages and forward to observable", function (done) {
            var server = dgram.createSocket("udp4");
            var client = dgram.createSocket("udp4");
            server.bind(SERVER_PORT, SERVER_HOST);
            var observable = rxUdp.observableFromSocket(function (b) { return b.toString("utf8"); }, server);
            var valuesSent = ["hello", "world", "!"];
            var valuesReceived = [];
            Rx.Observable.from(valuesSent).flatMap(function (value) {
                return Rx.Observable.fromNodeCallback(function (message, callback) {
                    var buffer = new Buffer(message, "utf8");
                    client.send(buffer, 0, buffer.byteLength, SERVER_PORT, SERVER_HOST, callback);
                })(value);
            }).subscribeOnCompleted(function () {
                setTimeout(function () {
                    server.close();
                }, 20);
            });
            observable.forEach(function (s) { return valuesReceived.push(s); });
            observable.subscribeOnCompleted(function () {
                // order is not important, reception is
                chai_1.expect(valuesReceived).to.have.length(3);
                chai_1.expect(valuesSent).to.include.members(valuesReceived);
                done();
            });
        });
        it("should error observable if socket errors", function (done) {
            var server = dgram.createSocket("udp4");
            var observable = rxUdp.observableFromSocket(function (b) { return b.toString("utf8"); }, server);
            observable.subscribeOnError(function (err) {
                chai_1.expect(err).to.be.an("Error");
                chai_1.expect(err.errno).to.equal("ENOTFOUND");
                chai_1.expect(err.code).to.equal("ENOTFOUND");
                chai_1.expect(err.syscall).to.equal("getaddrinfo");
                chai_1.expect(err.hostname).to.equal("INEXISTENT_HOST");
                done();
            });
            // should result in error ENOTFOUND being emitted 
            server.bind(SERVER_PORT, "INEXISTENT_HOST");
        });
    });
    describe("observer udp socket tests", function () {
        it("should close socket when observer completes", function (done) {
            var client = dgram.createSocket("udp4");
            var observer = rxUdp.observerForSocket(function (t) { return new Buffer(t); }, SERVER_PORT, SERVER_HOST, client);
            client.on("close", function () {
                done();
            });
            observer.onCompleted();
        });
        it("should close socket when observer errors", function (done) {
            var client = dgram.createSocket("udp4");
            var observer = rxUdp.observerForSocket(function (t) { return new Buffer(t); }, SERVER_PORT, SERVER_HOST, client);
            client.on("close", function () {
                done();
            });
            observer.onError(new Error("Something failed"));
        });
        it("should send data through socket when observer gets next value", function (done) {
            var valuesReceived = [];
            var server = dgram.createSocket("udp4", function (message) {
                valuesReceived.push(message.toString("utf8"));
            });
            server.bind(SERVER_PORT, SERVER_HOST);
            var client = dgram.createSocket("udp4");
            var observer = rxUdp.observerForSocket(function (t) { return new Buffer(t); }, SERVER_PORT, SERVER_HOST, client);
            var valuesSent = ["hello", "world", "!"];
            valuesSent.forEach(function (v) { return observer.onNext(v); });
            client.on("close", function () {
                // order is not important, reception is
                chai_1.expect(valuesReceived).to.have.length(3);
                chai_1.expect(valuesSent).to.include.members(valuesReceived);
                done();
            });
            setTimeout(function () {
                observer.onCompleted();
            }, 20);
        });
    });
});
//# sourceMappingURL=index.tests.js.map